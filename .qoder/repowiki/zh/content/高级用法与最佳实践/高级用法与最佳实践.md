# 高级用法与最佳实践

<cite>
**本文档引用的文件**  
- [LxnsApiCLient.ts](file://src/client/LxnsApiCLient.ts)
- [types.ts](file://src/client/types.ts)
- [public.ts](file://src/apis/maimai/public.ts)
- [dev.ts](file://src/apis/maimai/dev.ts)
- [personal.ts](file://src/apis/maimai/personal.ts)
- [index.ts](file://src/index.ts)
- [tsup.config.ts](file://tsup.config.ts)
- [package.json](file://package.json)
</cite>

## 目录
1. [自定义基础URL](#自定义基础url)  
2. [错误处理模式](#错误处理模式)  
3. [性能优化建议](#性能优化建议)  
4. [TypeScript类型扩展技巧](#typescript类型扩展技巧)  
5. [框架集成注意事项](#框架集成注意事项)  
6. [构建过程与产物说明](#构建过程与产物说明)  
7. [代码组织最佳实践](#代码组织最佳实践)

## 自定义基础URL

本SDK支持通过构造函数配置`baseURL`，以对接非官方API服务器或用于本地开发调试。默认值为`https://maimai.lxns.net/api/v0/`。

当传入`baseURL`时，所有API请求的前缀将被替换为指定地址，适用于：
- 本地开发环境（如`http://localhost:8080/api/v0/`）
- 测试服务器
- 社区维护的镜像服务

客户端会根据提供的token自动配置不同子域的HTTP实例：
- `public` API：使用`<baseURL>/maimai/`作为基础路径
- `dev` API：附加`Authorization`头
- `personal` API：使用`<baseURL>/user/maimai/`并附加`X-User-Token`

**Section sources**
- [LxnsApiCLient.ts](file://src/client/LxnsApiCLient.ts#L1-L81)

## 错误处理模式

推荐使用`try-catch`块捕获异步调用中的网络异常和API错误。由于底层使用`ky`库，其在HTTP状态码为4xx或5xx时会自动抛出异常。

建议按以下方式分类处理错误：

```ts
try {
  const player = await client.maimai.dev.getPlayer(friendCode);
} catch (error) {
  if (error.response) {
    switch (error.response.status) {
      case 401:
        console.error("认证失败，请检查 token 是否有效");
        break;
      case 404:
        console.error("玩家未找到");
        break;
      case 429:
        console.error("请求过于频繁，请稍后重试");
        break;
      default:
        console.error(`API 错误: ${error.response.status}`);
    }
  } else {
    console.error("网络连接失败，请检查网络状态");
  }
}
```

对于上传操作（如`postScores`），应特别关注400（数据格式错误）和422（校验失败）等状态码。

**Section sources**
- [dev.ts](file://src/apis/maimai/dev.ts#L1-L149)
- [personal.ts](file://src/apis/maimai/personal.ts#L1-L41)

## 性能优化建议

### 合理使用缓存

避免重复请求相同资源，例如歌曲列表、收藏品信息等静态数据。可结合内存缓存（如Map）或持久化存储（localStorage、Redis）实现。

示例：
```ts
const songCache = new Map<number, Song>();
async function getCachedSong(id: number) {
  if (songCache.has(id)) return songCache.get(id);
  const song = await client.maimai.public.getSong(id);
  songCache.set(id, song);
  return song;
}
```

### 批量上传成绩

当需要同步多条成绩时，应使用批量接口（如`postScores`）而非逐条发送，显著减少网络开销和服务器压力。

注意单次请求的数据量限制，必要时进行分页提交。

**Section sources**
- [dev.ts](file://src/apis/maimai/dev.ts#L130-L148)
- [personal.ts](file://src/apis/maimai/personal.ts#L35-L41)

## TypeScript类型扩展技巧

SDK利用条件类型实现了基于配置的API可用性推断。开发者可通过泛型和类型断言进一步扩展功能。

例如，若需访问未直接暴露的底层HTTP客户端：

```ts
// 类型断言获取内部实例（谨慎使用）
const httpDev = (client as any).maimai.dev.http;
```

也可通过交叉类型合并自定义方法：

```ts
declare module "lxns-rhythm-api" {
  interface MaiMaiOf<O> {
    customMethod?(): Promise<any>;
  }
}
```

利用`MaiMaiModels`导出的模型类型（如`Score`, `Player`）可确保数据结构一致性。

**Section sources**
- [types.ts](file://src/client/types.ts#L1-L33)
- [models.ts](file://src/apis/maimai/models.ts#L1-L282)
- [index.ts](file://src/index.ts#L1-L3)

## 框架集成注意事项

### 前端框架（React/Vue）

在组件中建议封装全局客户端实例，避免重复创建：

```ts
// React Context 示例
const ApiClientContext = createContext<LxnsApiClient>(null!);

export function useApiClient() {
  return useContext(ApiClientContext);
}
```

注意SSR场景下避免在服务端暴露敏感token，并合理管理生命周期。

### 后端服务（Node.js）

在Node.js环境中可安全存储token，建议通过环境变量注入：

```ts
const client = new LxnsApiClient({
  devAccessToken: process.env.DEV_TOKEN,
  baseURL: process.env.API_BASE_URL,
});
```

结合定时任务（如`node-cron`）实现定期数据同步。

**Section sources**
- [LxnsApiCLient.ts](file://src/client/LxnsApiCLient.ts#L1-L81)
- [package.json](file://package.json#L1-L50)

## 构建过程与产物说明

项目使用`tsup`进行构建，配置文件位于`tsup.config.ts`。当前仅生成ESM格式，输出至`dist/`目录。

构建脚本：
```json
"build": "tsup",
"build:production": "cross-env NODE_ENV=production tsup"
```

产物包含：
- `dist/index.js`：ES模块入口
- `dist/index.d.ts`：类型声明文件

`package.json`中通过`exports`字段明确导出规则，确保现代打包工具兼容性。

生成的代码为纯ESM格式，适用于支持`type: "module"`的运行时环境。

**Section sources**
- [tsup.config.ts](file://tsup.config.ts#L1-L20)
- [package.json](file://package.json#L1-L50)

## 代码组织最佳实践

建议将客户端实例封装为单例或依赖注入服务，便于统一管理配置和生命周期。

示例封装：

```ts
class ApiService {
  private static instance: LxnsApiClient;

  static getInstance(config?: LxnsApiClientOptions) {
    if (!this.instance) {
      this.instance = new LxnsApiClient(config);
    }
    return this.instance;
  }
}
```

或将不同权限的客户端分离：

```ts
const publicClient = new LxnsApiClient();
const devClient = new LxnsApiClient({ devAccessToken: TOKEN });
```

此模式有助于权限隔离和测试替身（mock）注入。

**Section sources**
- [LxnsApiCLient.ts](file://src/client/LxnsApiCLient.ts#L1-L81)
- [index.ts](file://src/index.ts#L1-L3)